{"id_cliente": "4445", "ficheros": [{"prueba (4.\u00aa copia).txt": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaa\n"}, {"prueba (otra copia).txt": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaa\n"}, {"prueba (3.\u00aa copia).txt": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaa\n"}, {"prueba (copia).txt": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaa\n"}, {"pruebagrande (1).txt": "This page intentionally left blank\nAlgorithms\nFOURTH EDITION\nThis page intentionally left blank\nAlgorithms\nRobert Sedgewick\nand\nKevin Wayne\nPrinceton University\nFOURTH EDITION\nUpper Saddle River, NJ \u2022 Boston \u2022 Indianapolis \u2022 San Francisco\nNew York \u2022 Toronto \u2022 Montreal \u2022 London \u2022 Munich \u2022 Paris \u2022 Madrid\nCapetown \u2022 Sydney \u2022 Tokyo \u2022 Singapore \u2022 Mexico City\nMany of the designations used by manufacturers and sellers to distinguish their products are claimed as\ntrademarks. Where those designations appear in this book, and the publisher was aware of a trademark\nclaim, the designations have been printed with initial capital letters or in all capitals.\nThe authors and publisher have taken care in the preparation of this book, but make no expressed or implied\nwarranty of any kind and assume no responsibility for errors or omissions. No liability is assumed\nfor incidental or consequential damages in connection with or arising out of the use of the information or\nprograms contained herein.\nThe publisher offers excellent discounts on this book when ordered in quantity for bulk purchases or\nspecial sales, which may include electronic versions and/or custom covers and content particular to your\nbusiness, training goals, marketing focus, and branding interests. For more information, please contact:\nU.S. Corporate and Government Sales\n(800) 382-3419\ncorpsales@pearsontechgroup.com\nFor sales outside the United States, please contact:\nInternational Sales\ninternational@pearson.com\nVisit us on the Web: informit.com/aw\nCataloging-in-Publication Data is on file with the Library of Congress.\nCopyright \u00a9 2011 Pearson Education, Inc.\nAll rights reserved. Printed in the United States of America. This publication is protected by copyright,\nand permission must be obtained from the publisher prior to any prohibited reproduction, storage in\na retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying,\nrecording, or likewise. For information regarding permissions, write to:\nPearson Education, Inc.\nRights and Contracts Department\n501 Boylston Street, Suite 900\nBoston, MA 02116\nFax: (617) 671-3447\nISBN-13: 978-0-321-57351-3\nISBN-10: 0-321-57351-X\nText printed in the United States on recycled paper at Courier in Westford, Massachusetts.\nFirst printing, March 2011\n______________________________\nTo Adam, Andrew, Brett, Robbie\nand especially Linda\n______________________________\n___________________\nTo Jackie and Alex\n___________________\nvi\nPreface . . . . . . . . . . . . . . . . . . . . . . . . .viii\n1 Fundamentals . . . . . . . . . . . . . . . . . . . . . .3\n1.1 Basic Programming Model 8\n1.2 Data Abstraction 64\n1.3 Bags, Queues, and Stacks 120\n1.4 Analysis of Algorithms 172\n1.5 Case Study: Union-Find 216\n2 Sorting . . . . . . . . . . . . . . . . . . . . . . . 243\n2.1 Elementary Sorts 244\n2.2 Mergesort 270\n2.3 Quicksort 288\n2.4 Priority Queues 308\n2.5 Applications 336\n3 Searching . . . . . . . . . . . . . . . . . . . . . . 361\n3.1 Symbol Tables 362\n3.2 Binary Search Trees 396\n3.3 Balanced Search Trees 424\n3.4 Hash Tables 458\n3.5 Applications 486\nCONTENTS\nvii\n4 Graphs . . . . . . . . . . . . . . . . . . . . . . . 515\n4.1 Undirected Graphs 518\n4.2 Directed Graphs 566\n4.3 Minimum Spanning Trees 604\n4.4 Shortest Paths 638\n5 Strings . . . . . . . . . . . . . . . . . . . . . . . 695\n5.1 String Sorts 702\n5.2 Tries 730\n5.3 Substring Search 758\n5.4 Regular Expressions 788\n5.5 Data Compression 810\n6 Context . . . . . . . . . . . . . . . . . . . . . . . 853\nIndex . . . . . . . . . . . . . . . . . . . . . . . . . 933\nAlgorithms . . . . . . . . . . . . . . . . . . . . . . 954\nClients . . . . . . . . . . . . . . . . . . . . . . . . 955\nviii\nThis book is intended to survey the most important computer algorithms in use today,\nand to teach fundamental techniques to the growing number of people in need of\nknowing them. It is intended for use as a textbook for a second course in computer\nscience, after students have acquired basic programming skills and familiarity with computer\nsystems. The book also may be useful for self-study or as a reference for people engaged in\nthe development of computer systems or applications programs, since it contains implementations\nof useful algorithms and detailed information on performance characteristics and\nclients. The broad perspective taken makes the book an appropriate introduction to the field.\nthe study of algorithms and data structures is fundamental to any computerscience\ncurriculum, but it is not just for programmers and computer-science students. Everyone\nwho uses a computer wants it to run faster or to solve larger problems. The algorithms\nin this book represent a body of knowledge developed over the last 50 years that has become\nindispensable. From N-body simulation problems in physics to genetic-sequencing problems\nin molecular biology, the basic methods described here have become essential in scientific\nresearch; from architectural modeling systems to aircraft simulation, they have become essential\ntools in engineering; and from database systems to internet search engines, they have\nbecome essential parts of modern software systems. And these are but a few examples\u2014as the\nscope of computer applications continues to grow, so grows the impact of the basic methods\ncovered here.\nBefore developing our fundamental approach to studying algorithms, we develop data\ntypes for stacks, queues, and other low-level abstractions that we use throughout the book.\nThen we survey fundamental algorithms for sorting, searching, graphs, and strings. The last\nchapter is an overview placing the rest of the material in the book in a larger context.\nPREFACE\nix\nDistinctive features The orientation of the book is to study algorithms likely to be of\npractical use. The book teaches a broad variety of algorithms and data structures and provides\nsufficient information about them that readers can confidently implement, debug, and\nput them to work in any computational environment. The approach involves:\nAlgorithms. Our descriptions of algorithms are based on complete implementations and on\na discussion of the operations of these programs on a consistent set of examples. Instead of\npresenting pseudo-code, we work with real code, so that the programs can quickly be put to\npractical use. Our programs are written in Java, but in a style such that most of our code can\nbe reused to develop implementations in other modern programming languages.\nData types. We use a modern programming style based on data abstraction, so that algorithms\nand their data structures are encapsulated together.\nApplications. Each chapter has a detailed description of applications where the algorithms\ndescribed play a critical role. These range from applications in physics and molecular biology,\nto engineering computers and systems, to familiar tasks such as data compression and searching\non the web.\nA scientific approach. We emphasize developing mathematical models for describing the\nperformance of algorithms, using the models to develop hypotheses about performance, and\nthen testing the hypotheses by running the algorithms in realistic contexts.\nBreadth of coverage. We cover basic abstract data types, sorting algorithms, searching algorithms,\ngraph processing, and string processing. We keep the material in algorithmic context,\ndescribing data structures, algorithm design paradigms, reduction, and problem-solving\nmodels. We cover classic methods that have been taught since the 1960s and new methods\nthat have been invented in recent years.\nOur primary goal is to introduce the most important algorithms in use today to as wide an\naudience as possible. These algorithms are generally ingenious creations that, remarkably, can\neach be expressed in just a dozen or two lines of code. As a group, they represent problemsolving\npower of amazing scope. They have enabled the construction of computational artifacts,\nthe solution of scientific problems, and the development of commercial applications\nthat would not have been feasible without them.\nx\nBooksite An important feature of the book is its relationship to the booksite\nalgs4.cs.princeton.edu. This site is freely available and contains an extensive amount of\nmaterial about algorithms and data structures, for teachers, students, and practitioners, including:\nAn online synopsis. The text is summarized in the booksite to give it the same overall structure\nas the book, but linked so as to provide easy navigation through the material.\nFull implementations. All code in the book is available on the booksite, in a form suitable for\nprogram development. Many other implementations are also available, including advanced\nimplementations and improvements described in the book, answers to selected exercises, and\nclient code for various applications. The emphasis is on testing algorithms in the context of\nmeaningful applications.\nExercises and answers. The booksite expands on the exercises in the book by adding drill\nexercises (with answers available with a click), a wide variety of examples illustrating the\nreach of the material, programming exercises with code solutions, and challenging problems.\nDynamic visualizations. Dynamic simulations are impossible in a printed book, but the\nwebsite is replete with implementations that use a graphics class to present compelling visual\ndemonstrations of algorithm applications.\nCourse materials. A complete set of lecture slides is tied directly to the material in the book\nand on the booksite. A full selection of programming assignments, with check lists, test data,\nand preparatory material, is also included.\nLinks to related material. Hundreds of links lead students to background information about\napplications and to resources for studying algorithms.\nOur goal in creating this material was to provide a complementary approach to the ideas.\nGenerally, you should read the book when learning specific algorithms for the first time or\nwhen trying to get a global picture, and you should use the booksite as a reference when programming\nor as a starting point when searching for more detail while online.\nxi\nUse in the curriculum The book is intended as a textbook in a second course in computer\nscience. It provides full coverage of core material and is an excellent vehicle for students\nto gain experience and maturity in programming, quantitative reasoning, and problemsolving.\nTypically, one course in computer science will suffice as a prerequisite\u2014the book is\nintended for anyone conversant with a modern programming language and with the basic\nfeatures of modern computer systems.\nThe algorithms and data structures are expressed in Java, but in a style accessible to\npeople fluent in other modern languages. We embrace modern Java abstractions (including\ngenerics) but resist dependence upon esoteric features of the language.\nMost of the mathematical material supporting the analytic results is self-contained (or\nis labeled as beyond the scope of this book), so little specific preparation in mathematics is\nrequired for the bulk of the book, although mathematical maturity is definitely helpful. Applications\nare drawn from introductory material in the sciences, again self-contained.\nThe material covered is a fundamental background for any student intending to major\nin computer science, electrical engineering, or operations research, and is valuable for any\nstudent with interests in science, mathematics, or engineering.\nContext The book is intended to follow our introductory text, An Introduction to Programming\nin Java: An Interdisciplinary Approach, which is a broad introduction to the field.\nTogether, these two books can support a two- or three-semester introduction to computer science\nthat will give any student the requisite background to successfully address computation\nin any chosen field of study in science, engineering, or the social sciences.\nThe starting point for much of the material in the book was the Sedgewick series of Algorithms\nbooks. In spirit, this book is closest to the first and second editions of that book, but\nthis text benefits from decades of experience teaching and learning that material. Sedgewick\u2019s\ncurrent Algorithms in C/C++/Java, Third Edition is more appropriate as a reference or a text\nfor an advanced course; this book is specifically designed to be a textbook for a one-semester\ncourse for first- or second-year college students and as a modern introduction to the basics\nand a reference for use by working programmers.\nxii\nAcknowledgments This book has been nearly 40 years in the making, so full recognition\nof all the people who have made it possible is simply not feasible. Earlier editions of this\nbook list dozens of names, including (in alphabetical order) Andrew Appel, Trina Avery, Marc\nBrown, Lyn Dupr\u00e9, Philippe Flajolet, Tom Freeman, Dave Hanson, Janet Incerpi, Mike Schidlowsky,\nSteve Summit, and Chris Van Wyk. All of these people deserve acknowledgement,\neven though some of their contributions may have happened decades ago. For this fourth\nedition, we are grateful to the hundreds of students at Princeton and several other institutions\nwho have suffered through preliminary versions of the work, and to readers around the world\nfor sending in comments and corrections through the booksite.\nWe are grateful for the support of Princeton University in its unwavering commitment\nto excellence in teaching and learning, which has provided the basis for the development of\nthis work.\nPeter Gordon has provided wise counsel throughout the evolution of this work almost\nfrom the beginning, including a gentle introduction of the \u201cback to the basics\u201d idea that is\nthe foundation of this edition. For this fourth edition, we are grateful to Barbara Wood for\nher careful and professional copyediting, to Julie Nahil for managing the production, and\nto many others at Pearson for their roles in producing and marketing the book. All were extremely\nresponsive to the demands of a rather tight schedule without the slightest sacrifice to\nthe quality of the result.\nRobert Sedgewick\nKevin Wayne\nPrinceton, NJ\nJanuary, 2011\nThis page intentionally left blank\n1.1 Basic Programming Model. . . . . . . . . 8\n1.2 Data Abstraction . . . . . . . . . . . . . . 64\n1.3 Bags, Queues, and Stacks . . . . . . . 120\n1.4 Analysis of Algorithms . . . . . . . . . 172\n1.5 Case Study: Union-Find. . . . . . . . . 216\nONE\nFundamentals\nThe objective of this book is to study a broad variety of important and useful\nalgorithms\u2014methods for solving problems that are suited for computer implementation.\nAlgorithms go hand in hand with data structures\u2014schemes for organizing\ndata that leave them amenable to efficient processing by an algorithm. This\nchapter introduces the basic tools that we need to study algorithms and data structures.\nFirst, we introduce our basic programming model. All of our programs are implemented\nusing a small subset of the Java programming language plus a few of our own\nlibraries for input/output and for statistical calculations. Section 1.1 is a summary of\nlanguage constructs, features, and libraries that we use in this book.\nNext, we emphasize data abstraction, where we define abstract data types (ADTs) in\nthe service of modular programming. In Section 1.2 we introduce the process of implementing\nan ADT in Java, by specifying an applications programming interface (API)\nand then using the Java class mechanism to develop an implementation for use in client\ncode.\nAs important and useful examples, we next consider three fundamental ADTs: the\nbag, the queue, and the stack. Section 1.3 describes APIs and implementations of bags,\nqueues, and stacks using arrays, resizing arrays, and linked lists that serve as models and\nstarting points for algorithm implementations throughout the book.\nPerformance is a central consideration in the study of algorithms. Section 1.4 describes\nour approach to analyzing algorithm performance. The basis of our approach is\nthe scientific method: we develop hypotheses about performance, create mathematical\nmodels, and run experiments to test them, repeating the process as necessary.\nWe conclude with a case study where we consider solutions to a connectivity problem\nthat uses algorithms and data structures that implement the classic union-find ADT.\n3\nAlgorithms When we write a computer program, we are generally implementing a\nmethod that has been devised previously to solve some problem. This method is often\nindependent of the particular programming language being used\u2014it is likely to be\nequally appropriate for many computers and many programming languages. It is the\nmethod, rather than the computer program itself, that specifies the steps that we can\ntake to solve the problem. The term algorithm is used in computer science to describe\na finite, deterministic, and effective problem-solving method suitable for implementation\nas a computer program. Algorithms are the stuff of computer science: they are\ncentral objects of study in the field.\nWe can define an algorithm by describing a procedure for solving a problem in a\nnatural language, or by writing a computer program that implements the procedure,\nas shown at right for Euclid\u2019s algorithm for finding the greatest common divisor of\ntwo numbers, a variant of which was devised\nover 2,300 years ago. If you are not familiar\nwith Euclid\u2019s algorithm, you are encouraged\nto work Exercise 1.1.24 and Exercise\n1.1.25, perhaps after reading Section 1.1. In\nthis book, we use computer programs to describe\nalgorithms. One important reason for\ndoing so is that it makes easier the task of\nchecking whether they are finite, deterministic,\nand effective, as required. But it is also\nimportant to recognize that a program in a\nparticular language is just one way to express\nan algorithm. The fact that many of the algorithms\nin this book have been expressed\nin multiple programming languages over the\npast several decades reinforces the idea that each algorithm is a method suitable for\nimplementation on any computer in any programming language.\nMost algorithms of interest involve organizing the data involved in the computation.\nSuch organization leads to data structures, which also are central objects of study\nin computer science. Algorithms and data structures go hand in hand. In this book we\ntake the view that data structures exist as the byproducts or end products of algorithms\nand that we must therefore study them in order to understand the algorithms. Simple\nalgorithms can give rise to complicated data structures and, conversely, complicated\nalgorithms can use simple data structures. We shall study the properties of many data\nstructures in this book; indeed, we might well have titled the book Algorithms and Data\nStructures.\nCompute the greatest common divisor of\ntwo nonnegative integers p and q as follows:\nIf q is 0, the answer is p. If not, divide p by q\nand take the remainder r. The answer is the\ngreatest common divisor of q and r.\npublic static int gcd(int p, int q)\n{\nif (q == 0) return p;\nint r = p % q;\nreturn gcd(q, r);\n}\nEuclid\u2019s algorithm\nJava-language description\nEnglish-language description\n4 CHAPTER 1 \u25a0 Fundamentals\nWhen we use a computer to help us solve a problem, we typically are faced with a\nnumber of possible approaches. For small problems, it hardly matters which approach\nwe use, as long as we have one that correctly solves the problem. For huge problems (or\napplications where we need to solve huge numbers of small problems), however, we\nquickly become motivated to devise methods that use time and space efficiently.\nThe primary reason to learn about algorithms is that this discipline gives us the\npotential to reap huge savings, even to the point of enabling us to do tasks that would\notherwise be impossible. In an application where we are processing millions of objects,\nit is not unusual to be able to make a program millions of times faster by using a welldesigned\nalgorithm. We shall see such examples on numerous occasions throughout\nthe book. By contrast, investing additional money or time to buy and install a new\ncomputer holds the potential for speeding up a program by perhaps a factor of only 10\nor 100. Careful algorithm design is an extremely effective part of the process of solving\na huge problem, whatever the applications area.\nWhen developing a huge or complex computer program, a great deal of effort must\ngo into understanding and defining the problem to be solved, managing its complexity,\nand decomposing it into smaller subtasks that can be implemented easily. Often,\nmany of the algorithms required after the decomposition are trivial to implement. In\nmost cases, however, there are a few algorithms whose choice is critical because most\nof the system resources will be spent running those algorithms. These are the types of\nalgorithms on which we concentrate in this book. We study fundamental algorithms\nthat are useful for solving challenging problems in a broad variety of applications areas.\nThe sharing of programs in computer systems is becoming more widespread, so\nalthough we might expect to be using a large fraction of the algorithms in this book, we\nalso might expect to have to implement only a small fraction of them. For example, the\nJava libraries contain implementations of a host of fundamental algorithms. However,\nimplementing simple versions of basic algorithms helps us to understand them better\nand thus to more effectively use and tune advanced versions from a library. More\nimportant, the opportunity to reimplement basic algorithms arises frequently. The primary\nreason to do so is that we are faced, all too often, with completely new computing\nenvironments (hardware and software) with new features that old implementations\nmay not use to best advantage. In this book, we concentrate on the simplest reasonable\nimplementations of the best algorithms. We do pay careful attention to coding the critical\nparts of the algorithms, and take pains to note where low-level optimization effort\ncould be most beneficial.\nThe choice of the best algorithm for a particular task can be a complicated process,\nperhaps involving sophisticated mathematical analysis. The branch of computer science\nthat comprises the study of such questions is called analysis of algorithms. Many\nCHAPTER 1 \u25a0 Fundamentals 5\nof the algorithms that we study have been shown through analysis to have excellent\ntheoretical performance; others are simply known to work well through experience.\nOur primary goal is to learn reasonable algorithms for important tasks, yet we shall also\npay careful attention to comparative performance of the methods. We should not use\nan algorithm without having an idea of what resources it might consume, so we strive\nto be aware of how our algorithms might be expected to perform.\nSummary of topics As an overview, we describe the major parts of the book, giving\nspecific topics covered and an indication of our general orientation toward the\nmaterial. This set of topics is intended to touch on as many fundamental algorithms as\npossible. Some of the areas covered are core computer-science areas that we study in\ndepth to learn basic algorithms of wide applicability. Other algorithms that we discuss\nare from advanced fields of study within computer science and related fields. The algorithms\nthat we consider are the products of decades of research and development and\ncontinue to play an essential role in the ever-expanding applications of computation.\nFundamentals (Chapter 1) in the context of this book are the basic principles and\nmethodology that we use to implement, analyze, and compare algorithms. We consider\nour Java programming model, data abstraction, basic data structures, abstract data\ntypes for collections, methods of analyzing algorithm performance, and a case study.\nSorting algorithms (Chapter 2) for rearranging arrays in order are of fundamental\nimportance. We consider a variety of algorithms in considerable depth, including insertion\nsort, selection sort, shellsort, quicksort, mergesort, and heapsort. We also encounter\nalgorithms for several related problems, including priority queues, selection,\nand merging. Many of these algorithms will find application as the basis for other algorithms\nlater in the book.\nSearching algorithms (Chapter 3) for finding specific items among large collections\nof items are also of fundamental importance. We discuss basic and advanced methods\nfor searching, including binary search trees, balanced search trees, and hashing. We\nnote relationships among these methods and compare performance.\nGraphs (Chapter 4) are sets of objects and connections, possibly with weights and\norientation. Graphs are useful models for a vast number of difficult and important\nproblems, and the design of algorithms for processing graphs is a major field of study.\nWe consider depth-first search, breadth-first search, connectivity problems, and several\nalgorithms and applications, including Kruskal\u2019s and Prim\u2019s algorithms for finding\nminimum spanning tree and Dijkstra\u2019s and the Bellman-Ford algorithms for solving\nshortest-paths problems.\n6 CHAPTER 1 \u25a0 Fundamentals\nStrings (Chapter 5) are an essential data type in modern computing applications.\nWe consider a range of methods for processing sequences of characters. We begin with\nfaster algorithms for sorting and searching when keys are strings. Then we consider\nsubstring search, regular expression pattern matching, and data-compression algorithms.\nAgain, an introduction to advanced topics is given through treatment of some\nelementary problems that are important in their own right.\nContext (Chapter 6) helps us relate the material in the book to several other advanced\nfields of study, including scientific computing, operations research, and the theory of\ncomputing. We survey event-based simulation, B-trees, suffix arrays, maximum flow,\nand other advanced topics from an introductory viewpoint to develop appreciation for\nthe interesting advanced fields of study where algorithms play a critical role. Finally, we\ndescribe search problems, reduction, and NP-completeness to introduce the theoretical\nunderpinnings of the study of algorithms and relationships to material in this book.\nThe study of algorithms is interesting and exciting because it is a new field\n(almost all the algorithms that we study are less than 50 years old, and some were just\nrecently discovered) with a rich tradition (a few algorithms have been known for hundreds\nof years). New discoveries are constantly being made, but few algorithms are\ncompletely understood. In this book we shall consider intricate, complicated, and difficult\nalgorithms as well as elegant, simple, and easy ones. Our challenge is to understand\nthe former and to appreciate the latter in the context of scientific and commercial applications.\nIn doing so, we shall explore a variety of useful tools and develop a style of\nalgorithmic thinking that will serve us well in computational challenges to come.\nCHAPTER 1 \u25a0 Fundamentals 7\n1.1 BASIC PROGRAMMING MODEL\nOur study of algorithms is based upon implementing them as programs written in\nthe Java programming language. We do so for several reasons:\n\u25a0 Our programs are concise, elegant, and complete descriptions of algorithms.\n\u25a0 You can run the programs to study properties of the algorithms.\n\u25a0 You can put the algorithms immediately to good use in applications.\nThese are important and significant advantages over the alternatives of working with\nEnglish-language descriptions of algorithms.\nA potential downside to this approach is that we have to work with a specific programming\nlanguage, possibly making it difficult to separate the idea of the algorithm\nfrom the details of its implementation. Our implementations are designed to mitigate\nthis difficulty, by using programming constructs that are both found in many modern\nlanguages and needed to adequately describe the algorithms.\n"}, {"prueba.txt": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaa\n"}, {"prueba (5.\u00aa copia).txt": "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaa\n"}, {"jojo.txt": "DIego es un gran ombre que rompe botellas y se queda dormido\nen plana reunion"}]}